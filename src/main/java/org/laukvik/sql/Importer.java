package org.laukvik.sql;


import org.laukvik.csv.CSV;
import org.laukvik.csv.CsvReader;
import org.laukvik.csv.ParseException;
import org.laukvik.csv.Row;
import org.laukvik.sql.ddl.*;
import org.laukvik.sql.swing.BackupFormatFileFilter;

import java.io.*;
import java.nio.charset.Charset;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Logger;

/**
 *
 */
public class Importer {

    private final static Logger LOG = Logger.getLogger(Importer.class.getName());
    private DatabaseConnection db;

    public Importer(DatabaseConnection databaseConnection) throws DatabaseReadOnlyException {
        this.db = databaseConnection;
        if (db.isReadOnly()){
            throw new DatabaseReadOnlyException(db.getFilename());
        }
    }



    /**
     * Reads Table definition persisted in a file
     *
     * @param table
     * @param file
     * @return
     * @throws ParseException
     * @throws IOException
     */
    public static Table readTableMetadata(String table, File file) throws ParseException, IOException {
        Table t = new Table( table );
        CSV csv = new CSV( file );
        for (int y=0; y<csv.getRowCount(); y++){
            //
            Row r = csv.getRow(y);
            //
            Column c = Column.parse( r.getInteger("type"), r.getString("column"));
            // Set properties
            c.setAllowNulls( r.getBoolean("allowNulls") );
            c.setPrimaryKey( r.getBoolean("primaryKey") );
            c.setForeignKey(  ForeignKey.parse(r.getString("foreignKey")));
            c.setAutoIncrement( r.getBoolean("autoIncrement") );
            c.setAutoGenerated(r.getBoolean("autoGenerated"));
            c.setComments(r.getString("comments"));
            c.setDefaultValue(r.getString("default"));
            c.setFormat(r.getString("format"));
            t.addColumn(c);
        }
        return t;
    }

    /**
     * Restores all data found in directory
     *
     * @param directory
     * @throws DatabaseReadOnlyException
     */
    public void importDirectory( File directory) throws DatabaseReadOnlyException {
        try {
            File [] files = directory.listFiles(new BackupFormatFileFilter());
            for (File f : files) {
                //if (f.getName().equalsIgnoreCase("activity.csv")) {
                    if (!f.getName().endsWith(".meta.csv")) {
                        String table = f.getName();
                        String tableName = table.substring(0, table.lastIndexOf(".csv"));
                        LOG.info("Importing table " + tableName);

                        File meta = new File(directory.getAbsolutePath(), tableName + ".meta.csv");

                        File data = new File(directory.getAbsolutePath(), tableName + ".csv");

                        importCSV(tableName, meta, data);
                    }
                //}
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Imports the specified table into the database. Both a metadata file and
     * the data file must be found in order to import.
     *
     * @throws Exception
     */
    public long importCSV( String tableName, File meta, File data ) throws Exception {

        //

        LOG.info("Reading meta file " + meta.getAbsolutePath());
        Table t = Importer.readTableMetadata(tableName,meta);
        createTable(t);


        LOG.info("Reading data file " + data.getAbsolutePath());
        InputStream is = new FileInputStream(data);

        CsvReader r = new CsvReader( is );
        System.out.println( r.getMetaData().getColumn(0).getName() );
        long updateCount = 0;
        long failedCount = 0;
        try(
                Connection conn = db.getConnection();
                Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
                ResultSet rs = st.executeQuery("SELECT * FROM " + tableName );
        ){
            int n = 1;
            while(r.hasNext()){

                Row row = r.getRow();
                try{
                    // Prepare new row
                    rs.moveToInsertRow();

                    // Fill data
                    for (int x=0; x<t.getColumns().size(); x++){
                        // Get column definition
                        Column c = t.getColumns().get(x);
                        int columnIndex = x+1;
                        if (c.isAutoGenerated() || c.isAutoIncrement()){
                             // Don't do anything with generated values
                        } else {
                            //
                            if (c instanceof IntegerColumn){
                                Integer value = row.getInteger(x);
                                rs.updateInt(columnIndex, value );

                            } else if (c instanceof BigIntColumn){
                                Integer value = row.getInteger(x);
                                rs.updateInt(columnIndex, value);

                            } else if (c instanceof VarCharColumn){
                                String value = row.getString(x);
                                rs.updateString(columnIndex, value);

                            } else if (c instanceof TimestampColumn){
                                String value = row.getString(x);
                                rs.updateString(columnIndex, value);

                            } else if (c instanceof DateColumn){
                                String value = row.getString(x);
                                DateColumn dc = (DateColumn)c;
                                if (value == null || value.trim().isEmpty()){
                                    rs.updateNull(columnIndex);
                                } else {
                                    SimpleDateFormat format = new SimpleDateFormat(dc.getFormat());
                                    Date date = format.parse( value );
                                    rs.updateDate(columnIndex, new java.sql.Date( date.getTime() ));
                                }

                            }
                        }
                    }

                    // Add new row
                    rs.insertRow();

                    updateCount++;
                    LOG.info("Row #" + n + " imported." );
                } catch(SQLException e2){
                    failedCount++;
                    LOG.info("Row #" + n + " - " + e2.getMessage() );
                }
                n++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        LOG.info("Imported " + updateCount + " rows. " + failedCount + " rows failed!" );
        return updateCount;
    }

    /**
     *
     * @param table
     */
    private void createTable( Table table ){
        try(
                Connection conn = db.getConnection();
                Statement st = conn.createStatement();
        ){
            int results = st.executeUpdate(table.getDDL());
            LOG.info("Created table " + table + " with " + table.getColumns().size() + " columns.");
            System.out.println( table.getDDL());
        } catch (Exception e) {
            LOG.info("Failed to create table " + table +"! (" + e.getMessage() + ")" );
            System.out.println( table.getDDL());
        }
    }



}
